<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Connecting up Google Cardboard to web APIs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
      #webglviewer {
        bottom: 0;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
      }
    </style>
  </head>
  <body>
    <div id="webglviewer"></div>

    <script src="./js/three.min.js"></script>
    <!-- Main minified library for three.js -->
    <script src="./js/StereoEffect.js"></script>
    <!-- Displays split in two -->
    <script src="./js/DeviceOrientationControls.js"></script>
    <!-- Where the devise is facing and where it is moving to -->
    <script src="./js/OrbitControls.js"></script>
    <!-- Controls the scene (mouse clicks or touch events) DeviseOrientation typically not available on computer testing (desktop) -->
    <script src="./js/helvetiker_regular.typeface.js"></script>
    <script src="https://cdn.timezonedb.com/js/timezonedb.min.js" type="text/javascript"></script>

    <script>
      var scene,
          camera,
          renderer,
          element,
          container,
          effect,
          controls,
          clock,

          // Particles (global variable)
          particles = new THREE.Object3D(),
          totalParticles = 200,
          maxParticleSize = 200,
          particleRotationSpeed = 0,
          particleRotationDeg = 0,
          lastColorRange = [0, 0.3],
          currentColorRange = [0, 0.3],

          // City and weather API set up
          cities = [['Sydney', '2147714'], ['New York', '5128638'], ['Tokyo', '1850147'], ['London', '2643743'], ['Mexico City', '3530597'], ['Miami', '4164138'], ['San Francisco', '5391959'], ['Rome', '3169070']],
          cityWeather = {},
          cityTimes = [],
          // Keep track of which city we're displaying in our series of cities
          currentCity = 0,
          currentCityText = new THREE.TextGeometry(),
          currentCityTextMesh = new THREE.Mesh();

      // Begin function
      init();

      function init() {
        // New scene
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.001, 700);
        // virtual height is most important
        camera.position.set(0, 15, 0);
        scene.add(camera);

        renderer = new THREE.WebGLRenderer();
        element = renderer.domElement;
        container = document.getElementById('webglviewer');
        container.appendChild(element);

        // VR stereoscopic view
        effect = new THREE.StereoEffect(renderer);

        // Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
        controls = new THREE.OrbitControls(camera, element);
        controls.target.set(
        // Target rotating spot 0.15 more than camera's x position, same y and z points
          camera.position.x + 0.15,
          camera.position.y,
          camera.position.z
        );
        // Panning and zooming off to avoid complications
        controls.noPan = true;
        controls.noZoom = true;

        // Our preferred controls via DeviceOrientation
        // Checking for alpha value (initial check)
        function setOrientationControls(e) {
          if (!e.alpha) {
            return;
          }

          // Browser will now move the device around
          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          controls.update();

          // Full screen on click
          // Excludes address bar
          element.addEventListener('click', fullscreen, false);

          // Remove Orientation Listener
          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }
        window.addEventListener('deviceorientation', setOrientationControls, true);
        // Track motion of the iPhone in Google Cardboard

        // Lighting
        // Light is angled
        var light = new THREE.PointLight(0x999999, 2, 100);
        light.position.set(50, 50, 50);
        scene.add(light);

        // Points straight down to light up where we will be standing
        var lightScene = new THREE.PointLight(0x999999, 2, 100);
        lightScene.position.set(0, 5, 0);
        scene.add(lightScene);

        // Giving floor context - image use from textures directory
        var floorTexture = THREE.ImageUtils.loadTexture('textures/wood.jpg');
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        // Size of the texture to be repeated
        floorTexture.repeat = new THREE.Vector2(50, 50);
        // Clear imagery on floor image
        floorTexture.anisotropy = renderer.getMaxAnisotropy();

        var floorMaterial = new THREE.MeshPhongMaterial({
          color: 0xffffff,
          specular: 0xffffff,
          shininess: 20,
          shading: THREE.FlatShading,
          map: floorTexture
        });

        // Defining three.js geometry from library of shapes
        var geometry = new THREE.PlaneBufferGeometry(1000, 1000);

        // Syncing geometry and floor material to make a tangible contextual object
        var floor = new THREE.Mesh(geometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        var particleTexture = THREE.ImageUtils.loadTexture('textures/particle.png'),
            spriteMaterial = new THREE.SpriteMaterial({
            map: particleTexture,
            color: 0xffffff
          });

        // Iterating through number of particles (200)
        for (var i = 0; i < totalParticles; i++) {
          var sprite = new THREE.Sprite(spriteMaterial);
          // Assigning spriteMaterial to new three.js object

          // Scale and position to same size as texture
          sprite.scale.set(64, 64, 1.0);
          // Particles in random positions
          sprite.position.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.75);
          sprite.position.setLength(maxParticleSize * Math.random());
          // Set particles to be between 0 and 200

          // Blending style (courtesy of three.js)
          sprite.material.blending = THREE.AdditiveBlending;

          particles.add(sprite);
        }
        // Raise particles so they are floating around the camera
        particles.position.y = 70;
        scene.add(particles);

        adjustToWeatherConditions();

        // Track time running in three.js experience
        // Tracks time between each render
        clock = new THREE.Clock();

        animate();
      }

      // API works best with one HTTParty request
      function adjustToWeatherConditions() {
        // cityIDs starts empty
        var cityIDs = '';
        for (var i = 0; i < cities.length; i++) {
          cityIDs += cities[i][1];
          if (i != cities.length - 1) cityIDs += ',';
        } // list of cities for get request containing both names and IDs
        getURL('http://api.openweathermap.org/data/2.5/group?id=' + cityIDs + '&APPID=b5c0b505a8746a1b2cc6b17cdab34535', function(info) {
          cityWeather = info.list;
          // Callback function that retrieves weather data for all cities under cityWeather variable. info.list returned in JSON contains info that we want

          // Pass in our weather array's length so for the amount of cities to loop through
          lookupTimezones(0, cityWeather.length);
        });
      }

      // Retrieves time in respectable location
      // Pass a value of 0 to look up timezone for first city
      function lookupTimezones(t, len) {
        var tz = new TimeZoneDB;
        // Functions BEGINS by using tx variable (we have access from timezonedb.js)

        tz.getJSON({
            key: "GPH4A5Q6NGI1",
            lat: cityWeather[t].coord.lat,
            lng: cityWeather[t].coord.lon
        }, function(timeZone){
            cityTimes.push(new Date(timeZone.timestamp * 1000));
            // Each timzone at each location is stored in cityTimes data array
            t++;

            // t = index
            // len - length of weather data array
            if (t < len) {
              setTimeout(function() {
                lookupTimezones(t, len);
              }, 1200);
            } else {
              applyWeatherConditions();
            }
        });
      }
      // setTimeout avoids abundance of loops/second. Loops have 1200 millisecond delay between

      function applyWeatherConditions() {
        // displayCurrentCityName adds 3D text
        displayCurrentCityName(cities[currentCity][0]);

        // Assign weather data to info for clear reference
        var info = cityWeather[currentCity];

        // Wind in miles/second divided by 2 (slowed down to see the particles)
        particleRotationSpeed = info.wind.speed / 2; // dividing by 2 just to slow things down
        // Represents the wind direction in degrees
        particleRotationDeg = info.wind.deg;

        // getUTCHours pulls out the hour value
        var timeThere = cityTimes[currentCity] ? cityTimes[currentCity].getUTCHours() : 0,
            isDay = timeThere >= 6 && timeThere <= 18;
            // Determines day or night broadly

        // Set particle coloration based on cases
        if (isDay) {
          switch (info.weather[0].main) {
            case 'Clouds':
              // [hue of color, saturation]
              currentColorRange = [0, 0.01];
              // Hue is 0 when cloudy (white)
              break;
            case 'Rain':
              currentColorRange = [0.7, 0.1];
              // Hue is blue and darker when rainy
              break;
            case 'Clear':
            default:
              currentColorRange = [0.6, 0.7];
              // Hue is blue and light when clear
              break;
          }
        } else {
          currentColorRange = [0.69, 0.6];
          // Otherwise at night, hue is purple and lighter
        }

        if (currentCity < cities.length-1) currentCity++;
        else currentCity = 0;

        // 5 second setTimeout
        setTimeout(applyWeatherConditions, 5000);
      }

      // Display current city name
      function displayCurrentCityName(name) {
        scene.remove(currentCityTextMesh);

        // Passes in appropriate text
        // Set up fully opaque, white ext
        currentCityText = new THREE.TextGeometry(name, {
          size: 4,
          height: 1
        });
        currentCityTextMesh = new THREE.Mesh(currentCityText, new THREE.MeshBasicMaterial({
          color: 0xffffff, opacity: 1
        }));

        currentCityTextMesh.position.y = 10;
        currentCityTextMesh.position.z = 20;
        currentCityTextMesh.rotation.x = 0;
        currentCityTextMesh.rotation.y = -180;

        scene.add(currentCityTextMesh);
      }

      // Move and refresh on each frame
      // First run on end of init()
      function animate() {
        // Gets number of second that three.js scene has been running
        // Stores within elapsedSeconds
        var elapsedSeconds = clock.getElapsedTime(),
            particleRotationDirection = particleRotationDeg <= 180 ? -1 : 1;
            // Rotate particles clockwise at less than or equal to 180 degrees
            // Otherwise rotate counter-clockwise

        // Calculate number of seconds animation has been running, multiplies by speed travelled and direction we'd like them to go
        particles.rotation.y = elapsedSeconds * particleRotationSpeed * particleRotationDirection;

        // We check if the color range has changed, if so, we'll change the colours
        if (lastColorRange[0] != currentColorRange[0] && lastColorRange[1] != currentColorRange[1]) {

          for (var i = 0; i < totalParticles; i++) {
            particles.children[i].material.color.setHSL(currentColorRange[0], currentColorRange[1], (Math.random() * (0.7 - 0.2) + 0.2));
          }

          lastColorRange = currentColorRange;
        }

        // Set animate() to run again next animation frame
        requestAnimationFrame(animate);

        // Keeps our renderer, camera object and controls matching the browser viewport size
        update(clock.getDelta());
        // Renders our scene on each frame. Effect is called to render it using the stereoscopic effect set up earlier
        render(clock.getDelta());
      }

      function resize() {
        var width = container.offsetWidth;
        var height = container.offsetHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        effect.setSize(width, height);
      }

      function update(dt) {
        resize();

        camera.updateProjectionMatrix();

        controls.update(dt);
      }

      function render(dt) {
        effect.render(scene, camera);
      }

      function fullscreen() {
        if (container.requestFullscreen) {
          container.requestFullscreen();
        } else if (container.msRequestFullscreen) {
          container.msRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
          container.mozRequestFullScreen();
        } else if (container.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        }
      }

      function getURL(url, callback) {
        var xmlhttp = new XMLHttpRequest();

        xmlhttp.onreadystatechange = function() {
          if (xmlhttp.readyState == 4) {
             if (xmlhttp.status == 200){
                 callback(JSON.parse(xmlhttp.responseText));
             }
             else {
                 console.log('We had an error, status code: ', xmlhttp.status);
             }
          }
        }

        xmlhttp.open('GET', url, true);
        xmlhttp.send();
      }
    </script>
  </body>
</html>
